# This file contains tests that require our cross-compilation environment


@testset "Builder Dependency" begin
    BinDeps2.temp_prefix() do prefix
        # First, let's create a Dependency that just installs a file
        cd("build_tests") do
            # Our simple executable file, generated by bash
            test_exe = BinDeps2.FileResult(joinpath(BinDeps2.bindir(prefix),"test_exe"))
            results = [test_exe]

            # Remember that we don't need to use `bash()` here because these commands
            # will be happening within the cross-compilation environment
            cmds = Cmd[]
            push!(cmds, `mkdir -p $(BinDeps2.bindir(prefix))`)
            push!(cmds, `bash -c "printf '#!/bin/bash\necho test' > $(test_exe.path)"`)
            push!(cmds, `chmod 775 $(test_exe.path)`)
            
            dep = BinDeps2.Dependency("bash_test", results, cmds, platform, prefix)

            @test BinDeps2.build(dep; verbose=true)
            @test BinDeps2.satisfied(dep)
            @test readstring(`$(test_exe.path)`) == "test\n"
        end

        # Next, build a simple shared library and an executable
        cd("build_tests/libfoo") do
            libfoo = BinDeps2.LibraryResult(joinpath(BinDeps2.libdir(prefix), "libfoo"))
            fooifier = BinDeps2.FileResult(joinpath(BinDeps2.bindir(prefix), "fooifier"))
            steps = [`make clean`, `make install`]
            dep = BinDeps2.Dependency("foo", [libfoo, fooifier], steps, platform, prefix)

            # Build it
            @test BinDeps2.build(dep; verbose=true)
            @test BinDeps2.satisfied(dep; verbose=true)

            # Test the binaries
            check_foo(fooifier.path, libfoo.path)

            # Also test the binaries through `activate()`
            BinDeps2.activate(prefix)
            check_foo()
            BinDeps2.deactivate(prefix)

            # Test that `collect_files()` works:
            all_files = BinDeps2.collect_files(prefix)
            @test libfoo.path in all_files
            @test fooifier.path in all_files
        end
    end

    BinDeps2.temp_prefix() do prefix
        # Next, work in two layers of dependencies.  We'll build `libfoo` just like
        # above, but we'll explicitly model `fooifier` as a separate, Dependency
        cd("build_tests/libfoo") do
            libfoo = BinDeps2.LibraryResult(joinpath(BinDeps2.libdir(prefix), "libfoo"))
            cmds = [`make install-libfoo`]
            dep_libfoo = BinDeps2.Dependency("libfoo", [libfoo], cmds, platform, prefix)

            fooifier = BinDeps2.FileResult(joinpath(BinDeps2.bindir(prefix), "fooifier"))
            cmds = [`make install-fooifier`]
            dep_fooifier = BinDeps2.Dependency("fooifier", [fooifier], cmds, platform, prefix, [dep_libfoo])

            # Build fooifier, which should invoke libfoo automagically
            @test BinDeps2.build(dep_fooifier; verbose=true)

            # Test the binaries
            check_foo(fooifier.path, libfoo.path)

            # Make sure once it's built, it doesn't auto-build again
            info("The following two builds should not need to be run")
            BinDeps2.build(dep_fooifier; verbose=true)
        end
    end
end

@testset "Builder Packaging" begin
    # Clear out previous build products
    for f in readdir(".")
        if !endswith(f, ".tar.gz")
            continue
        end
        rm(f; force=true)
    end
    
    # Gotta set this guy up beforehand
    tarball_path = nothing

    BinDeps2.temp_prefix() do prefix
        cd("build_tests/libfoo") do
            # First, build libfoo
            libfoo = BinDeps2.LibraryResult(joinpath(BinDeps2.libdir(prefix), "libfoo"))
            fooifier = BinDeps2.FileResult(joinpath(BinDeps2.bindir(prefix), "fooifier"))
            steps = [`make clean`, `make install`]
            dep = BinDeps2.Dependency("foo", [libfoo, fooifier], steps, platform, prefix)

            @test BinDeps2.build(dep)
        end    
        
        # Next, package it up as a .tar.gz file
        tarball_path = BinDeps2.package(prefix, "./libfoo"; verbose=true)
        @test isfile(tarball_path)
    end

    libfoo_hash = open(tarball_path, "r") do f
        bytes2hex(sha256(f))
    end

    # Test that we can inspect the contents of the tarball
    contents = BinDeps2.list_tarball_files(tarball_path)
    @test "bin/fooifier" in contents
    @test "lib/libfoo.$(Libdl.dlext)" in contents

    # Install it within a new Prefix
    BinDeps2.temp_prefix() do prefix
        # Install the thing
        @test BinDeps2.install(tarball_path, libfoo_hash; prefix=prefix, verbose=true)

        # Ensure we can use it
        fooifier_path = joinpath(BinDeps2.bindir(prefix), "fooifier")
        libfoo_path = joinpath(BinDeps2.libdir(prefix), "libfoo.$(Libdl.dlext)")
        check_foo(fooifier_path, libfoo_path)
    end

    rm(tarball_path; force=true)
end

@testset "Builder Nettle" begin
    BinDeps2.temp_prefix() do prefix
        # Some useful directories
        src_path = joinpath(prefix, "src")
        build_path = joinpath(prefix, "build")
        try mkpath(src_path) end
        try mkpath(build_path) end

        # First, download the sources, store them into /src
        src_url = "https://ftp.gnu.org/gnu/nettle/nettle-3.3.tar.gz"
        src_hash = "46942627d5d0ca11720fec18d81fc38f7ef837ea4197c1f630e71ce0d470b11e"        
        BinDeps2.download_verify_unpack(src_url, src_hash, src_path; verbose=true)

        # Copy in our nettle build script to /build
        cp(joinpath("build_tests", "nettle", "build_nettle.sh"), joinpath(build_path,"build_nettle.sh"))

        # Build for many platforms
        for platform in BinDeps2.supported_platforms()
            cd(build_path) do
                target = BinDeps2.platform_map(platform)
                libnettle = BinDeps2.LibraryResult(joinpath(BinDeps2.libdir(prefix), target, "libnettle"))
                nettlehash = BinDeps2.FileResult(joinpath(BinDeps2.bindir(prefix), target, "nettle-hash"))

                steps = [`bash ./build_nettle.sh $(prefix.path)`]
                dep = BinDeps2.Dependency("nettle", [libnettle, nettlehash], steps, platform, prefix)
                BinDeps2.build(dep; verbose=true)
            end
        end
    end
end
